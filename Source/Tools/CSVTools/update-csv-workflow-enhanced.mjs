import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { spawn } from 'node:child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const workspaceRoot = process.cwd();

function executeScript(scriptPath, label, options = {}) {
  const { env: extraEnv } = options;

  return new Promise((resolve, reject) => {
    console.log(`\n>>> ${label}`);
    console.log('-'.repeat(60));

    const child = spawn('node', [scriptPath], {
      cwd: workspaceRoot,
      stdio: 'inherit',
      env: {
        ...process.env,
        ...extraEnv,
      },
    });

    child.on('close', (code) => {
      if (code === 0) {
        console.log('-'.repeat(60));
        console.log(`${label} completed successfully.`);
        resolve();
      } else {
        reject(new Error(`${label} exited with code ${code}`));
      }
    });

    child.on('error', (error) => {
      reject(new Error(`Failed to launch ${label}: ${error.message}`));
    });
  });
}

async function main() {
  console.clear();
  console.log('='.repeat(60));
  console.log('CSV PROJECT MAP - ENHANCED WORKFLOW');
  console.log('='.repeat(60));
  console.log('This workflow runs:');
  console.log('  1) File system to CSV synchronization');
  console.log('  2) Function extraction (Column J)');
  console.log('  3) Order of operations extraction (Column K)');
  console.log('  4) Dependencies extraction (Column L)');
  console.log('  5) Data flow extraction (Column M)');
  console.log('  6) Lines-of-code counting (Column N)');
  console.log('  7) Input/output mapping (Column O)');
  console.log('  8) Side effects extraction (Column P)');
  console.log('  9) Cyclomatic complexity extraction (Column Y)');
  console.log(' 10) Feature synopsis extraction (Column FEATURES)');
  console.log('='.repeat(60));

  const startTime = Date.now();

  try {
    const syncScriptPath = path.join(__dirname, 'sync-filesystem-to-csv.mjs');
    await executeScript(syncScriptPath, 'File System Synchronization');

    const snapshotPath = await findLatestSnapshot();
    if (!snapshotPath) {
      throw new Error('No snapshot CSV was generated by the synchronization step.');
    }

    console.log('\nLatest snapshot:');
    console.log(`  ${snapshotPath}`);
    console.log('\n' + '='.repeat(60));

    const functionsScriptPath = path.join(__dirname, 'update-functions.mjs');
    await executeScript(functionsScriptPath, 'Function Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    console.log('\n' + '='.repeat(60));

    const orderScriptPath = path.join(__dirname, 'updateOrderOfOperations.mjs');
    await executeScript(orderScriptPath, 'Order Of Operations Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    console.log('\n' + '='.repeat(60));

    const depsScriptPath = path.join(__dirname, 'updateDependencies.mjs');
    await executeScript(depsScriptPath, 'Dependencies Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    console.log('\n' + '='.repeat(60));

    const dataFlowScriptPath = path.join(__dirname, 'updateDataFlow.mjs');
    await executeScript(dataFlowScriptPath, 'Data Flow Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    const locScriptPath = path.join(__dirname, 'updateLinesOfCodeCounter.mjs');
    await executeScript(locScriptPath, 'Lines Of Code Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    const ioScriptPath = path.join(
      __dirname,
      'updateInputSourcesOutputDestinations.mjs'
    );
    await executeScript(
      ioScriptPath,
      'Input Sources & Output Destinations Extraction',
      {
        env: {
          CSV_PROJECT_MAP_PATH: snapshotPath,
        },
      }
    );

    const sideEffectsScriptPath = path.join(__dirname, 'updateSideEffects.mjs');
    await executeScript(sideEffectsScriptPath, 'Side Effects Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    const complexityScriptPath = path.join(
      __dirname,
      'updateCyclomaticComplexity.mjs'
    );
    await executeScript(complexityScriptPath, 'Cyclomatic Complexity Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    const featuresScriptPath = path.join(__dirname, 'updateFeatures.mjs');
    await executeScript(featuresScriptPath, 'Feature Synopsis Extraction', {
      env: {
        CSV_PROJECT_MAP_PATH: snapshotPath,
      },
    });

    const durationSeconds = ((Date.now() - startTime) / 1000).toFixed(2);

    console.log('\n' + '='.repeat(60));
    console.log('ENHANCED WORKFLOW COMPLETE');
    console.log('='.repeat(60));
    console.log(`Duration: ${durationSeconds} seconds`);
    console.log(`Updated snapshot: ${snapshotPath}`);
    console.log(
      'Columns refreshed: FUNCTIONS (J), ORDER_OF_OPERATIONS (K), DEPENDENCIES (L), DATA FLOW / STATE MANAGEMENT (M), LINES OF CODE (N), INPUT SOURCES / OUTPUT DESTINATIONS (O), SIDE EFFECTS (P), CYCLOMATIC COMPLEXITY (Y), FEATURES.'
    );
    console.log('Base CSV left untouched.');
  } catch (error) {
    console.error('\n' + '='.repeat(60));
    console.error('WORKFLOW FAILED');
    console.error('='.repeat(60));
    console.error(error.stack || error.message);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('\nFatal error while running workflow.');
  console.error(error.stack || error.message);
  process.exit(1);
});

async function findLatestSnapshot() {
  const snapshotDir = path.join(workspaceRoot, 'Source/ProjectMap');
  let entries;
  try {
    entries = await fs.readdir(snapshotDir, { withFileTypes: true });
  } catch (error) {
    console.warn(`Unable to read snapshot directory: ${error.message}`);
    return null;
  }

  const candidates = entries
    .filter((entry) => entry.isFile() && isSnapshotFilename(entry.name))
    .map((entry) => entry.name);

  if (candidates.length === 0) {
    return null;
  }

  let latestPath = null;
  let latestTime = -Infinity;

  await Promise.all(
    candidates.map(async (name) => {
      const absolutePath = path.join(snapshotDir, name);
      const stats = await fs.stat(absolutePath);
      const modifiedMs = stats.mtimeMs ?? stats.mtime.getTime();
      if (modifiedMs > latestTime) {
        latestTime = modifiedMs;
        latestPath = absolutePath;
      }
    })
  );

  return latestPath;
}

function isSnapshotFilename(name) {
  return (
    /^SourceFolder-[A-Za-z]{3}-\d{2}-\d{4}-\d{2}-\d{2}-(am|pm)-and-\d{2}-seconds\.csv$/i.test(
      name
    ) ||
    /^FolderStructure_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}\.csv$/i.test(name)
  );
}



